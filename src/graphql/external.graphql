scalar ObjectId
scalar Date

#ROOT===========================================
type Query {
    GetMe: User!
    GetMyVehicles(skip: Int, limit: Int @constraint(max: 10)): [Vehicle!]!
    GetMyBankAccounts(skip: Int, limit: Int @constraint(max: 10)): [BankAccount!]!

    GetMyHostedTrips(skip: Int, limit: Int @constraint(max: 10)): [HostedTrip]!
    GetMyHostedTrip(_id: ObjectId!): HostedTrip!

    GetMyRequestedTrips(skip: Int, limit: Int @constraint(max: 10)): [RequestedTrip]!
    GetMyRequestedTrip(_id: ObjectId!): RequestedTrip!

    GetMySentHandshakes(skip: Int, limit: Int @constraint(max: 10)): [Handshake]!
    GetMyReceivedHandshakes(skip: Int, limit: Int @constraint(max: 10)): [Handshake]!
    GetMyHandshake(_id: ObjectId!): Handshake!

    GetMatchingRequestedTrips(hostedTripId: ObjectId!): [RequestedTripMatch!]!
}

type Mutation {
    CreateGenericUser(user: UserInput!): String!
    SignIn(mobile: String!, password: String!): String!

    AddVehicle(vehicle: VehicleInput!): ObjectId!

    AddBankAccount(bankAccount: BankAccountInput!): ObjectId!

    AddHostedTrip(hostedTrip: HostedTripInput!): ObjectId!

    AddRequestedTrip(requestedTrip: RequestedTripInput!): ObjectId!
}

#USER===========================================
type User {
    _id: ObjectId!
    isActive: Boolean!
    mobile: String!
    email: String!
    preferredName: String!
    currentCoord: [Float!]
    rating: UserRating!
}

input UserInput {
    mobile: String! @constraint(pattern: "^\\+94\\d{9}$")
    password: String! @constraint(minLength: 4)
    email: String! @constraint(format: "email")
    preferredName: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
}

#RATING=========================================
type HostRating {
    politeness: Float!,
    punctuality: Float!,
    driving: Float!,
    meetsCondition: Float!,
}

type RequesterRating {
    politeness: Float!,
    punctuality: Float!,
}

type VehicleRating {
    cleanliness: Float!
    ac: Float!
}

type UserRating{
    asHost: HostRating!
    asRequester: RequesterRating!
}

type TripRating {
    host: HostRating!
    requester: RequesterRating!
    vehicle: VehicleRating!
}

#TIME===========================================
type TripTime {
    schedule: Date!
    start: Date #If this is available and "end" is not available, trip is ongoing
    end: Date
}

input TripTimeInput {
    schedule: Date!
}

type HandshakeTime {
    sent: Date!
    accepted: Date #If available, handshake is accepted by recipient
}

#VEHICLE========================================
type Vehicle {
    _id: ObjectId!
    isActive: Boolean!
    name: String!
    number: String!
    model: String!
    features: VehicleFeatures!
    rating: VehicleRating!
}

input VehicleInput {
    name: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    number: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    model: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    features: VehicleFeaturesInput!
}

type VehicleFeatures {
    ac: Boolean!
    luggage: Boolean!
}

input VehicleFeaturesInput {
    ac: Boolean!
    luggage: Boolean!
}

#TRIP===========================================
type HostedTrip {
    _id: ObjectId!
    host: User!
    route: HostedTripRoute!
    time: TripTime!
    vehicle: Vehicle! #Could be a temporary or saved
    seats: Int!
    billing: TripBilling!
}

input HostedTripInput {
    route: HostedTripRouteInput!
    time: TripTimeInput!
    vehicleId: ObjectId #If vehicle is null, then this must not
    vehicle: VehicleInput  #If vehicleId is null, then this must not
    seats: Int! @constraint(min: 1)
    billing: TripBillingInput!
}

type TripBilling {
    bankAccount: BankAccount!
    priceFirstKm: Float!
    priceNextKm: Float!
}

input TripBillingInput {
    bankAccountId: ObjectId!
    priceFirstKm: Float! @constraint(min: 0)
    priceNextKm: Float! @constraint(min: 0)
}

type RequestedTrip {
    _id: ObjectId!
    requester: User!
    route: RequestedTripRoute!
    time: TripTime!
    seats: Int!
}

input RequestedTripInput {
    route: RequestedTripRouteInput!
    time: TripTimeInput!
    seats: Int! @constraint(min: 1)
}

#ROUTE==========================================
type HostedTripRoute {
    from: String!
    to: String!
    polyLines: [String!]!
    keyCoords: [[Float!]!]!
}

input HostedTripRouteInput {
    from: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    to: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    polyLines: [String!]! @constraint(minItems: 1)
    keyCoords: [[Float!]!]! @constraint(minItems: 2)
}

type RequestedTripRoute {
    from: String!
    to: String!
    keyCoords: [[Float!]!]!
}

input RequestedTripRouteInput {
    from: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    to: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    keyCoords: [[Float!]!]! @constraint(minItems: 2)
}

#HANDSHAKE======================================
type Handshake {
    _id: ObjectId!
    sender: User!
    recipient: User!
    hostedTrip: HostedTrip!
    requestedTrip: RequestedTrip!
    time: HandshakeTime!
    payment: Payment!
    rating: TripRating!
}

type Payment {
    amount: Float!
    time: Date #If available, payment is done
}

#TRIP_MATCH====================================
type RequestedTripMatch {
    requestedTrip: RequestedTrip!
    results: [TripMatchResult!]!
}

type TripMatchResult {
    hostedTripLength: Float!
    requestedTripLength: Float!
    intersectionLength: Float!
    hostedTripCoverage: Float!
    requestedTripCoverage: Float!
    intersectionPolyLine: String!
}

#BANK_ACCOUNT=============================
type BankAccount {
    _id: ObjectId!
    isActive: Boolean!
    name: String!
    bank: String!
    number: String!
    branch: String!
}

input BankAccountInput {
    name: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    bank: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
    number: String! @constraint(pattern: "^[0-9\\s]{3,20}$")
    branch: String! @constraint(pattern: "^[a-zA-Z0-9\\s]{3,20}$")
}